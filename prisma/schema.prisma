generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
}

model User {
  id              String   @id @default(cuid())
  email           String   @unique
  name            String
  phone           String?
  password        String
  skillLevel      String?  @default("C")
  emailVerified   DateTime?
  emailNotifications Boolean @default(true)
  smsNotifications Boolean @default(false)
  resetToken      String?
  resetTokenExpiry DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  isAdmin         Boolean  @default(false)

  registrations   LeagueRegistration[]
  matchesAsPlayer1 Match[] @relation("Player1Matches")
  matchesAsPlayer2 Match[] @relation("Player2Matches")
  matchesAsPlayer3 Match[] @relation("Player3Matches")
  matchesAsPlayer4 Match[] @relation("Player4Matches")
  disputedScores  DisputedScore[]
  sessions        Session[]
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model League {
  id                String   @id @default(cuid())
  name              String
  gameType          GameType @default(SINGLES)
  rankingMethod     RankingMethod @default(BY_WINS)
  startDate         DateTime
  endDate           DateTime
  registrationOpens DateTime
  registrationCloses DateTime
  status            LeagueStatus @default(UPCOMING)
  pointsToWin       Int      @default(15)
  winByTwo          Boolean  @default(true)
  isFree            Boolean  @default(true)
  leagueFee         Float?   @default(0)
  playersPerMatch   Int      @default(2)  // 2 for singles, 3 for cut-throat, 4 for doubles
  matchDuration     Int      @default(45) // minutes per match including 5min warmup
  weeksForCutthroat Int?     // number of weeks for cut-throat leagues
  scheduleGenerated Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  registrations     LeagueRegistration[]
  matches           Match[]
  divisions         Division[]
}

model Division {
  id        String   @id @default(cuid())
  name      String
  level     String
  leagueId  String
  league    League   @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  registrations LeagueRegistration[]
  matches       Match[]

  @@unique([leagueId, level])
}

model LeagueRegistration {
  id               String   @id @default(cuid())
  userId           String
  leagueId         String
  divisionId       String?
  registrationDate DateTime @default(now())
  status           RegistrationStatus @default(PENDING)
  paymentStatus    PaymentStatus @default(UNPAID)

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  league   League   @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  division Division? @relation(fields: [divisionId], references: [id])

  @@unique([userId, leagueId])
}

model Court {
  id        String   @id @default(cuid())
  name      String
  number    Int      @unique // Court 1 or Court 2
  location  String?
  isActive  Boolean  @default(true)

  availability       CourtAvailability[]
  globalAvailability GlobalCourtAvailability[]
  matches            Match[]
}

model CourtAvailability {
  id         String   @id @default(cuid())
  courtId    String
  dayOfWeek  Int      // 0 = Sunday, 1 = Monday, etc.
  startTime  String   // "18:00" format
  endTime    String   // "22:00" format
  isActive   Boolean  @default(true)

  court      Court    @relation(fields: [courtId], references: [id], onDelete: Cascade)

  @@unique([courtId, dayOfWeek, startTime])
}

model GlobalCourtAvailability {
  id         String   @id @default(cuid())
  dayOfWeek  Int      // 0 = Sunday, 1 = Monday, etc.
  startTime  String   // "18:00" format
  endTime    String   // "22:00" format
  isActive   Boolean  @default(true)
  courtId    String?  // Optional court ID for court-specific availability
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  court      Court?   @relation(fields: [courtId], references: [id], onDelete: Cascade)

  @@unique([dayOfWeek, startTime, courtId])
}

model Match {
  id            String   @id @default(cuid())
  leagueId      String
  divisionId    String?
  weekNumber    Int?     // Week number in the league schedule
  player1Id     String
  player2Id     String
  player3Id     String?  // For cut-throat
  player4Id     String?  // For doubles
  courtId       String?
  courtNumber   Int?     // 1 or 2
  scheduledTime DateTime
  actualTime    DateTime?
  isMakeup      Boolean  @default(false) // True if this is a makeup match
  status        MatchStatus @default(SCHEDULED)

  // Score tracking - supports multiple games
  games         Game[]
  winnerId      String?

  // Score confirmation
  player1Confirmed Boolean @default(false)
  player2Confirmed Boolean @default(false)
  scoreReportedBy String?
  scoreReportedAt DateTime?
  scoreDisputed   Boolean @default(false)
  disputeReason   String?

  // Disputed scores tracking
  disputedScores DisputedScore[]

  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  league        League   @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  division      Division? @relation(fields: [divisionId], references: [id])
  player1       User     @relation("Player1Matches", fields: [player1Id], references: [id])
  player2       User     @relation("Player2Matches", fields: [player2Id], references: [id])
  player3       User?    @relation("Player3Matches", fields: [player3Id], references: [id])
  player4       User?    @relation("Player4Matches", fields: [player4Id], references: [id])
  court         Court?   @relation(fields: [courtId], references: [id])
}

model Game {
  id            String   @id @default(cuid())
  matchId       String
  gameNumber    Int
  player1Score  Int
  player2Score  Int
  player3Score  Int?     // For cut-throat
  winnerId      String?
  createdAt     DateTime @default(now())

  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, gameNumber])
}

model DisputedScore {
  id            String   @id @default(cuid())
  matchId       String
  gameNumber    Int
  player1Score  Int
  player2Score  Int
  player3Score  Int?
  reportedBy    String
  createdAt     DateTime @default(now())

  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  reporter      User     @relation(fields: [reportedBy], references: [id])

  @@index([matchId])
}

enum GameType {
  SINGLES
  DOUBLES
  CUTTHROAT
}

enum RankingMethod {
  BY_WINS
  BY_POINTS
}

enum LeagueStatus {
  UPCOMING
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
  WAITLIST
}

enum PaymentStatus {
  UNPAID
  PAID
  REFUNDED
  PENDING
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  POSTPONED
  NO_SHOW
  DISPUTED
}
